<!DOCTYPE html>
<html>
<head>
  <style id="app-style">
    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;
    }

    .perspective {
      backface-visibility: hidden;
      transform-style: preserve-3d;
      position: fixed;
      top: 0;
      font-size: 0;
      left: 0;
      background: transparent;
      width: 70%;
      height: 100%;
      perspective-origin: center;
      transform: rotateX(75deg) rotateZ(-20deg);
    }

    .fixed {
      position: fixed;
      top: 0;
      right: 0;
      width: 30%;
      height: 100%;
      z-index: 1;
      background: #eeeeee;
    }

    .background-board {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: #eeeeee80;
    }

    .container {
      display: inline-block;
      position: absolute;
      left: 50%;
      top: 50%;
      transform-style: preserve-3d;
    }

    .entity,
    .virtual {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .zft {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      display: block;
      background: transparent;
      transform-style: preserve-3d;
    }

    .zft span {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: 0% 0%;
      opacity: .5;
    }

    .zft span:nth-child(2) {
      transform: rotateX(90deg);
    }

    .zft span:nth-child(3) {
      transform: translateX(100%) rotateY(-90deg);
    }

    .zft span:nth-child(4) {
      transform: rotateY(-90deg);
    }

    .zft span:nth-child(5) {
      transform: translateY(100%) rotateX(90deg);
    }

    .zft.h1 span:nth-child(1),
    .zft.h2 span:nth-child(2),
    .zft.h3 span:nth-child(3),
    .zft.h4 span:nth-child(4),
    .zft.h5 span:nth-child(5),
    .zft.h6 span:nth-child(6) {
      background: transparent !important;
    }
  </style>
  <style id="var-style">
    .background-board {
      transform: translateZ(-90px);
    }

    .container {
      width: 60px;
      height: 60px;
      transform: translate3d(-50%, -50%, -30px);
    }

    .zft span:nth-child(6) {
      transform: translateZ(60px);
    }
  </style>
</head>

<body>
  <div class="perspective">
    <div class="background-board"></div>
    <div class="container">
      <div class="entity"></div>
      <div class="virtual"></div>
    </div>
  </div>
  <div class="fixed">
  </div>
</body>
<script src="./index.js"></script>
<script>
  const ReactData = new Proxy({ size: 60 }, {
    set(target, propKey, value) {
      switch (propKey) {
        case 'size':
          if (target[propKey] !== value) {
            const sheet = target.$varStyle.sheet
            sheet.removeRule(0)
            sheet.removeRule(0)
            sheet.removeRule(0)
            sheet.insertRule(`.zft span:nth-child(6) {transform: translateZ(${value}px);}`, 0)
            sheet.insertRule(`.container {width: ${value}px;height: ${value}px;transform: translate3d(-50%,-50%,-${value / 2}px);}`, 0)
            sheet.insertRule(`.background-board {transform: translateZ(-${value * 1.5 - (target.boardAbove || 0)}px);}`, 0)
          }
          break
        case 'boardAbove':
          if (target[propKey] !== value && typeof value === 'number') {
            sheet.removeRule(0)
            sheet.insertRule(`.background-board {transform: translateZ(-${value * 1.5 - (target.boardAbove || 0)}px);}`, 0)
          }
          break
        default:
          break
      }
      target[propKey] = value
      return true
    }
  })
  class SmallCube {
    constructor(parentNode, site = [0, 0, 0], size = ReactData.size) {
      const _this = this
      _this.site = [...site]
      _this.hideFace = {}
      _this.size = size
      parentNode.appendChild(_this.createEl())
      _this.style = new Proxy({}, {
        set(target, propKey, value) {
          if (typeof value === 'string' && target[propKey] !== value) {
            target[propKey] = value
            _this.upStyle(propKey, value)
            return true
          } else {
            return true
          }
        },
        deleteProperty(target, propKey) {
          delete target[propKey]
          _this.upStyle(propKey)
          return true
        }
      })
      return new Proxy(this, {
        set(target, propKey, value) {
          if (propKey === 'site') {
            target.site = value
            target.el.style = target.styleobj2str()
            return true
          } else {
            return Reflect.set(target, propKey, value)
          }
        },
        get(target, propKey) {
          return Reflect.get(target, propKey)
        }
      })
    }
    upStyle(key, value) {
      const childrenStyle = ['background', 'opacity']
      if (value !== void 0) {
        if (childrenStyle.includes(key)) {
          Array.prototype.forEach.call(this.el.children, node => {
            node.style.setProperty(key, value)
          })
        } else {
          this.el.style.setProperty(key, value)
        }
      } else {
        if (childrenStyle.includes(key)) {
          Array.prototype.forEach.call(this.el.children, node => {
            node.style.removeProperty(key)
          })
        } else {
          this.el.style.removeProperty(key)
        }
      }
    }
    styleobj2str(obj) {
      obj = obj || {}
      obj.width = obj.width || this.size
      obj.height = obj.height || this.size
      obj.transform = obj.transform || { translate: [] }
      for (let name in obj) {
        const value = obj[name]
        const tp = typeof value
        switch (name) {
          case 'width': case 'height':
            if (tp === 'number') {
              obj[name] = value + 'px'
            } else if (tp !== 'stirng') {
              delete obj[name]
            }
            break
          case 'transform':
            if (tp === 'object') {
              obj[name] = [value.translate ? `translate3d(${(this.site[2] - 1 + (value.translate[0] || 0)) * ReactData.size}px,${(this.site[1] - 1 + (value.translate[1] || 0)) * ReactData.size}px,${(this.site[0] - 1 + (value.translate[2] || 0)) * ReactData.size}px)` : '',
              value.rotate ? [
                value.rotate[0] ? `rotateX(${value.rotate[0]}deg)` : '',
                value.rotate[1] ? `rotateY(${value.rotate[1]}deg)` : '',
                value.rotate[2] ? `rotateZ(${value.rotate[2]}deg)` : ''].join(' ') : ''].join(' ')
            } else if (tp !== 'string') {
              delete obj[name]
            }
            break
          default:
            if (tp !== 'string') {
              delete obj[name]
            }
            break
        }
      }
      return Object.keys(obj).map(key => `${key}:${obj[key]}`).join(';')
    }
    changeSize(size) {
      if (size !== this.size) {
        this.size = size
        this.el.children[5].style.transform = `translateZ(${this.size}px)`
      }
    }
    createEl() {
      const zft = document.createElement('div')
      zft.className = 'zft'
      const [f, r, c] = this.site
      zft.dataset.id = (3 - f) * 1000 + [4, 2, 1][c] * 10 ** (2 - r)
      zft.style = this.styleobj2str()
      for (let i = 0; i < 6; i++) {
        const span = document.createElement('span')
        if (i === 5) {
          span.style.transform = `translateZ(${this.size}px)`
        }
        zft.appendChild(span)
      }
      this.el = zft
      return zft
    }
    setGrid(arr) {//[2001,...]

    }
    setHideClass(noHide) {
      this.el.className = noHide ? 'zft' : ['zft', ...Object.keys(this.hideFace).map(item => item - -1)].join(' h')
    }
    hide() {
      this.upStyle('opacity', '0')
    }
    show() {
      this.upStyle('opacity', this.style.opacity || '0.8')
    }
  }

  class Block {
    constructor(cubes, parent) {
      this.hub = {}
      this.cubes = cubes
      this.parent = parent
      /* numArr.map(item => nums2arrs(item)).forEach((a, ai) => {
        a.forEach((b, bi) => {
          b.forEach((c, ci) => {
            if (c) {
              const str = (ai + 1) * 1000 + [4, 2, 1][ci] * 10 ** (2 - bi)
              this.hub[str] = luban[2 - ai][bi][ci]
            }
          })
        })
      }) */
      //this.setHideFace(bgColor, noHide)
    }
    init(numArr, bgColor, noHide) {
      this.setSite(numArr)
      this.setColor(bgColor)
      this.setHideFace(bgColor, noHide)
    }
    setSite(numArr) {
      numArr.numSort().forEach((item, index) => {
        const cube = this.cubes[index]
        this.hub[item] = cube
        cube.site = point2site(item)
      })
    }
    setColor(color) {
      this.bgColor = color
    }
    setHideFace(color, noHide) {
      for (let point in this.hub) {
        const one = this.hub[point]
        const cp = points[point]
        for (let c in cp) {
          const p = cp[c]
          if (c in this.hub) {
            this.hub[c].hideFace[5 - p.cs] = point
            one.hideFace[p.cs] = c
          }
        }
      }
      for (let k in this.hub) {
        this.hub[k].style.background = color
        this.hub[k].show()
        this.hub[k].setHideClass(noHide)
      }
    }
    setStyle(style) {
      for (let k in this.hub) {
        Object.assign(this.hub[k].style, style)
      }
    }
    hideSelf() {
      for (let k in this.hub) {
        this.hub[k].hide()
      }
    }
    showSelf() {
      for (let k in this.hub) {
        this.hub[k].show()
      }
    }
    hideSelf() {
      for (let k in this.hub) {
        this.hub[k].hide()
      }
    }
    hideOther() {
      this.parent.forEach(item => {
        if (item !== this) {
          item.hideSelf()
        } else {
          item.showSelf()
        }
      })
    }
  }

  class ACB { // assemble cube
    constructor(isWhole, el, size) {// num = 27|4|3
      const blocks = [[]]
      this.blocks = []
      const df = document.createDocumentFragment()
      for (let i = 0; i < (isWhole ? 27 : 4); i++) {
        const item = new SmallCube(df)
        if (isWhole) {
          if (i % 4 === 3) {
            blocks.push([item])
          } else {
            blocks.last().push(item)
          }
        } else {
          blocks[0].push(item)
        }
      }
      blocks.forEach(item => {
        this.blocks.push(new Block(item, this.blocks))
      })
      el.appendChild(df)
    }
    load(data, colors, noHide) {
      this.show()
      let p3
      const res = data.map(item => block2points(item)).filter(item => item.length === 3 ? (p3 = item, false) : true);
      ([p3, ...res]).forEach((item, index) => {
        this.blocks[index].init(item, (colors && colors[index]) || 'transparent', noHide)
      })
    }
    show(indexs) {
      const isArr = Array.isArray(indexs)
      this.blocks.forEach((item, index) => {
        if ((isArr && indexs.includes(index)) || index === indexs) {
          item.showSelf()
        } else {
          item.hideSelf()
        }
      })
    }
    hide(indexs) {
      const isArr = Array.isArray(indexs)
      this.blocks.forEach((item, index) => {
        if ((isArr && indexs.includes(index)) || index === indexs) {
          item.hideSelf()
        } else {
          item.showSelf()
        }
      })
    }
  }

  // [<,-][田,T,刁,L,Z,厶,マ]
  const bulks = {
    '-2': {
      points: [1040, 1002, 1004],
      offset: [0.5, 0.5, -1]
    },
    '-1': {
      points: [1004, 2004, 3004],
      offset: [1, 1, 0]
    },
    0: {
      points: [1040, 1020, 1004, 1002],
      offset: [0.5, 0.5, -1]
    },
    1: {
      points: [1020, 1004, 1002, 1001],
      offset: [0, 0.5, -1]
    },
    2: {
      points: [1040, 1020, 1004, 2040],
      offset: [0.5, 0.5, -0.5]
    },
    3: {
      points: [1040, 1004, 1002, 1001],
      offset: [0, 0.5, -1]
    },
    4: {
      points: [1040, 1020, 1002, 1001],
      offset: [0, 0.5, -1]
    },
    5: {
      points: [1040, 1020, 1004, 2020],
      offset: [0.5, 0.5, -0.5]
    },
    6: {
      points: [1040, 1020, 1004, 2004],
      offset: [0.5, 0.5, -0.5]
    }
  }
  class Bulk {
    constructor(arr) {
      this.hub = arr
    }
    load(id) { // 

    }
  }

  function createBlocks(str) {//-1123456
    str += ''
    const arr = str.split('')
    const b3 = -arr[1]
    const b4s = str.slice
  }

  function ready(fn) {
    document.addEventListener('DOMContentLoaded', function readyFn() {
      document.removeEventListener('DOMContentLoaded', readyFn, false)
      fn()
    }, false)
  }

  class TouchEvent {
    constructor($body) {
      $body.ontouchstart = this.startHandle
      $body.ontouchend = this.endHandle
    }
    register() { }
    startHandle() { }
    endHandle() { }
    moveHandle() { }
  }

  ready(function () {
    ReactData.$body = document.body
    ReactData.$pb = document.querySelector('.perspective')
    ReactData.$ct = document.querySelector('.container')
    ReactData.$varStyle = document.querySelector('#var-style')
    ReactData.$fixed = document.querySelector('.fixed')
    const { $body, $pb, $ct, $fixed } = ReactData
    let r = 1
    let startPos = null
    let posRotate = [75, -20]

    if ($pb) {
      function mouseMove(event) {
        console.log(395, event)
        if (event.buttons !== 1) {
          $body.ontouchmove = null
        } else {
          let dx = event.pageX - startPos[0]
          let dy = event.pageY - startPos[1]
          $pb.style.transform = `rotateX(${posRotate[0] - dy * r}deg) rotateZ(${posRotate[1] - dx * r}deg)`
        }
      }
      $body.ontouchstart = function (event) {
        console.log(405, event)
        startPos = [event.pageX, event.pageY]
        $body.ontouchmove = mouseMove
      }
      $body.ontouchend = function (event) {
        console.log(410, event)
        posRotate[1] -= event.pageX - startPos[0]
        posRotate[0] -= event.pageY - startPos[1]
        startPos = null
        $body.onmousemove = null
      }

      const shadow = {
        hub: {},
        assembled: [],
        actived: [],
        rested: [],
        init() {
          this.rested.length = 0
          this.actived.length = 0
          this.assembled.length = 0
          for (k in this.hub) {
            this.rested.push(k)
            this.hub[k].style.background = '#4cbbf380'
          }
        }
      }
      const df = document.createDocumentFragment()
      for (let f = 2; f >= 0; f--) {
        for (let r = 0; r < 3; r++) {
          for (let c = 0; c < 3; c++) {
            str = (3 - f) * 1000 + [4, 2, 1][c] * 10 ** (2 - r)
            shadow.hub[str] = new SmallCube(df, [f, r, c])
          }
        }
      }
      $ct.children[1].appendChild(df)
      shadow.init()
      const exhibit = new ACB(true, $ct.children[0], 60)
      exhibit.load([
        [1000, 2000, 3170],
        [1000, 2011, 3003],
        [1000, 2320, 3200],
        [1004, 2004, 3004],
        [1013, 2002, 3000],
        [1040, 2440, 3400],
        [1720, 2000, 3000]
      ], ['red', 'orange', 'yellow', 'green', 'cyan', 'blue', 'purple'])
      window.$ehb = exhibit



      // 创建操作区
      /* function createOperationBlocks(num, blocks) {
        const ob = document.createElement('div')
        ob.className = 'operation-blocks'
        for (let i = 0; i < num; i++) {
          blocks[i] = new SmallCube(ob)
        }
        return ob
      }
      const odf = document.createDocumentFragment()
      const operationBlocks = [[]]
      odf.appendChild(createOperationBlocks(3, operationBlocks[0]))
      for (let i = 1; i < 7; i++) {
        operationBlocks[i] = []
        odf.appendChild(createOperationBlocks(4, operationBlocks[i]))
      }

      $fixed.appendChild(odf) */

      /* ReactData.collection = {
        arr: [],
        load(data, colors, noHide) {
          this.show()
          this.arr.length = 0
          data.forEach((a, i) => this.arr.push(new Block(a, luban, (colors && colors[i]) || 'white', this.arr, noHide)))
        },
        show(indexs) {
          const isArr = Array.isArray(indexs)
          this.arr.forEach((item, index) => {
            if ((isArr && indexs.includes(index)) || index === indexs) {
              item.showSelf()
            } else {
              item.hideSelf()
            }
          })
        },
        hide(indexs) {
          const isArr = Array.isArray(indexs)
          this.arr.forEach((item, index) => {
            if ((isArr && indexs.includes(index)) || index === indexs) {
              item.hideSelf()
            } else {
              item.showSelf()
            }
          })
        },
      } */
    }
  })
</script>
</html>