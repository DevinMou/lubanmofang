<!DOCTYPE html>
<html>
<head>
  <meta name="viewport"
    content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no,minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <!-- <meta name="full-screen" content="yes" />
  <meta name="x5-fullscreen" content="yes" />
  <meta name="browsermode" content="application" />
  <meta name="x5-page-mode" content="app" /> -->

  <style id="app-style">
    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;
      touch-action: none;
    }

    .main {
      background: #ffffff;
      overflow: hidden;
      position: fixed;
      top: 0;
      left: 0;
      width: 70%;
      height: 100%;
    }

    .perspective {
      backface-visibility: hidden;
      transform-style: preserve-3d;
      position: absolute;
      top: 0;
      font-size: 0;
      left: 0;
      background: transparent;
      width: 100%;
      height: 100%;
      perspective-origin: center;
      transform: rotateX(75deg) rotateZ(-20deg);
    }

    .fixed {
      position: fixed;
      top: 0;
      right: 0;
      width: 30%;
      height: 100%;
      z-index: 1;
      background: #eeeeee;
    }

    .fixed .swiper {
      position: relative;
      width: 100%;
      height: 100%;
    }

    .fixed .swiper>div {
      position: absolute;
      width: 30vw;
      height: 30vw;
      left: 0;
      transform-origin: center;
      top: calc(50vh - 15vw);
    }

    /* .fixed .swiper>div:nth-child(1) {
      background: red;
    }

    .fixed .swiper>div:nth-child(2) {
      background: orange;
    }

    .fixed .swiper>div:nth-child(3) {
      background: yellow;
    }

    .fixed .swiper>div:nth-child(4) {
      background: green;
    }

    .fixed .swiper>div:nth-child(5) {
      background: cyan;
    }

    .fixed .swiper>div:nth-child(6) {
      background: blue;
    }

    .fixed .swiper>div:nth-child(7) {
      background: purple;
    } */

    .background-board {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: #eeeeee80;
    }

    .container {
      display: inline-block;
      position: absolute;
      left: 50%;
      top: 50%;
      transform-style: preserve-3d;
    }

    .entity,
    .virtual {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .zft {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      display: block;
      background: transparent;
      transform-style: preserve-3d;
    }

    .zft span {
      width: 100%;
      height: 100%;
      position: absolute;
      box-sizing: border-box;
      top: 0;
      left: 0;
      transform-origin: 0% 0%;
      opacity: .5;
    }

    .zft span:nth-child(2) {
      transform: rotateX(90deg);
    }

    .zft span:nth-child(3) {
      transform: translateX(100%) rotateY(-90deg);
    }

    .zft span:nth-child(4) {
      transform: rotateY(-90deg);
    }

    .zft span:nth-child(5) {
      transform: translateY(100%) rotateX(90deg);
    }

    /*[down:b,r,back:t,r,right:b,r,left:t,l,front:b,l,top:t,l]*/
    .zft.h1 span:nth-child(1),
    .zft.h2 span:nth-child(2),
    .zft.h3 span:nth-child(3),
    .zft.h4 span:nth-child(4),
    .zft.h5 span:nth-child(5),
    .zft.h6 span:nth-child(6) {
      background: transparent !important;
    }

    .zft.grid span {
      background: #4cbbf380;
    }

    .zft.grid span:nth-child(1) {
      border-right: 1px dashed #ffffff;
      border-bottom: 1px dashed #ffffff;
    }

    .zft.grid.g0 span:nth-child(1) {
      background: transparent !important;
      border-right: 0;
      border-bottom: 0;
    }

    .zft.grid span:nth-child(2) {
      border-right: 1px dashed #ffffff;
      border-top: 1px dashed #ffffff;
    }

    .zft.grid.g1 span:nth-child(2) {
      background: transparent !important;
      border-right: 0;
      border-top: 0;
    }

    .zft.grid span:nth-child(3) {
      border-right: 1px dashed #ffffff;
      border-bottom: 1px dashed #ffffff;
    }

    .zft.grid.g2 span:nth-child(3) {
      background: transparent !important;
      border-right: 0;
      border-bottom: 0;
    }

    .zft.grid span:nth-child(4) {
      border-left: 1px dashed #ffffff;
      border-top: 1px dashed #ffffff;
    }

    .zft.grid.g3 span:nth-child(4) {
      border-left: 0;
      border-top: 0;
    }

    .zft.grid span:nth-child(5) {
      border-left: 1px dashed #ffffff;
      border-bottom: 1px dashed #ffffff;
    }

    .zft.grid.g4 span:nth-child(5) {
      border-left: 0;
      border-bottom: 0;
    }

    .zft.grid span:nth-child(6) {
      border-left: 1px dashed #ffffff;
      border-top: 1px dashed #ffffff;
    }

    .zft.grid.g5 span:nth-child(6) {
      border-left: 0;
      border-top: 0;
    }
  </style>
  <style>
    .part {
      position: relative;
      transform-style: preserve-3d;
    }

    .part.center {
      background-color: #70bae685;
    }

    .part-perspective {
      backface-visibility: hidden;
      transform-style: preserve-3d;
      perspective-origin: center;
      /* transform: rotateX(75deg) rotateZ(-20deg); */
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      font-size: 0;
    }

    /* .part-perspective::after {
      content: '';
      display: block;
      width: 10px;
      height: 10px;
      background-color: #ffffff;
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    } */

    .part-container {
      width: 30px;
      height: 30px;
      transform: translate3d(-50%, -50%, 0);
      display: inline-block;
      position: absolute;
      top: 50%;
      left: 50%;
      transform-style: preserve-3d;
    }
  </style>
  <style id="touch-style">
    .main-touch,
    .deputy-touch {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
    }
  </style>
  <style id="var-style">
    .background-board {
      transform: translateZ(-90px);
    }

    .container {
      width: 60px;
      height: 60px;
      transform: translate3d(-50%, -50%, -30px);
    }

    .zft span:nth-child(6) {
      transform: translateZ(60px);
    }
  </style>
</head>

<body>
  <div class="main">
    <div class="perspective">
      <div class="background-board"></div>
      <div class="container">
        <div class="entity"></div>
        <div class="virtual"></div>
      </div>
    </div>
    <div class="main-touch"></div>
  </div>
  <div class="fixed">
    <div class="swiper">
    </div>
    <div class="deputy-touch"></div>
  </div>
</body>
<script src="./index.js"></script>
<script>
  const ReactData = new Proxy({ size: 60 }, {
    set(target, propKey, value) {
      switch (propKey) {
        case 'size':
          if (target[propKey] !== value) {
            const sheet = target.$varStyle.sheet
            sheet.removeRule(0)
            sheet.removeRule(0)
            sheet.removeRule(0)
            sheet.insertRule(`.zft span:nth-child(6) {transform: translateZ(${value}px);}`, 0)
            sheet.insertRule(`.container {width: ${value}px;height: ${value}px;transform: translate3d(-50%,-50%,-${value / 2}px);}`, 0)
            sheet.insertRule(`.background-board {transform: translateZ(-${value * 1.5 - (target.boardAbove || 0)}px);}`, 0)
          }
          break
        case 'boardAbove':
          if (target[propKey] !== value && typeof value === 'number') {
            sheet.removeRule(0)
            sheet.insertRule(`.background-board {transform: translateZ(-${value * 1.5 - (target.boardAbove || 0)}px);}`, 0)
          }
          break
        default:
          break
      }
      target[propKey] = value
      return true
    }
  })
  class SmallCube {
    constructor(parentNode, site = [0, 0, 0], size = ReactData.size) {
      const _this = this
      _this.site = [...site]
      _this.hideFace = {}
      _this.size = size
      parentNode.appendChild(_this.createEl())
      _this.style = new Proxy({}, {
        set(target, propKey, value) {
          if (typeof value === 'string' && target[propKey] !== value) {
            target[propKey] = value
            _this.upStyle(propKey, value)
            return true
          } else {
            return true
          }
        },
        deleteProperty(target, propKey) {
          delete target[propKey]
          _this.upStyle(propKey)
          return true
        }
      })
      return new Proxy(this, {
        set(target, propKey, value) {
          if (propKey === 'site') {
            target.site = value
            target.el.style = target.styleobj2str()
            return true
          } else {
            return Reflect.set(target, propKey, value)
          }
        },
        get(target, propKey) {
          return Reflect.get(target, propKey)
        }
      })
    }
    getSiteStr() {
      const [f, r, c] = this.site
      return (3 - f) * 1000 + [4, 2, 1][c] * 10 ** (2 - r)
    }
    upStyle(key, value) {
      const childrenStyle = ['background', 'opacity']
      if (value !== void 0) {
        if (childrenStyle.includes(key)) {
          Array.prototype.forEach.call(this.el.children, node => {
            node.style.setProperty(key, value)
          })
        } else {
          this.el.style.setProperty(key, value)
        }
      } else {
        if (childrenStyle.includes(key)) {
          Array.prototype.forEach.call(this.el.children, node => {
            node.style.removeProperty(key)
          })
        } else {
          this.el.style.removeProperty(key)
        }
      }
    }
    styleobj2str(obj) {
      obj = obj || {}
      obj.width = obj.width || this.size
      obj.height = obj.height || this.size
      obj.transform = obj.transform || { translate: [] }
      for (let name in obj) {
        const value = obj[name]
        const tp = typeof value
        switch (name) {
          case 'width': case 'height':
            if (tp === 'number') {
              obj[name] = value + 'px'
            } else if (tp !== 'stirng') {
              delete obj[name]
            }
            break
          case 'transform':
            if (tp === 'object') {
              obj[name] = [value.translate ? `translate3d(${(this.site[2] - 1 + (value.translate[0] || 0)) * this.size}px,${(this.site[1] - 1 + (value.translate[1] || 0)) * this.size}px,${(this.site[0] - 1 + (value.translate[2] || 0)) * this.size}px)` : '',
              value.rotate ? [
                value.rotate[0] ? `rotateX(${value.rotate[0]}deg)` : '',
                value.rotate[1] ? `rotateY(${value.rotate[1]}deg)` : '',
                value.rotate[2] ? `rotateZ(${value.rotate[2]}deg)` : ''].join(' ') : ''].join(' ')
            } else if (tp !== 'string') {
              delete obj[name]
            }
            break
          default:
            if (tp !== 'string') {
              delete obj[name]
            }
            break
        }
      }
      return Object.keys(obj).map(key => `${key}:${obj[key]}`).join(';')
    }
    changeSize(size) {
      if (size !== this.size) {
        this.size = size
        this.el.children[5].style.transform = `translateZ(${this.size}px)`
      }
    }
    createEl() {
      const zft = document.createElement('div')
      zft.className = 'zft'
      const [f, r, c] = this.site
      zft.dataset.id = (3 - f) * 1000 + [4, 2, 1][c] * 10 ** (2 - r)
      zft.style = this.styleobj2str()
      for (let i = 0; i < 6; i++) {
        const span = document.createElement('span')
        if (i === 5) {
          span.style.transform = `translateZ(${this.size}px)`
        }
        zft.appendChild(span)
      }
      this.el = zft
      return zft
    }
    setGrid(arr, color) {//[2001,...]
      const siteStr = this.getSiteStr()
      const point = points[siteStr]
      const edges = Object.values(point).map(item => 'g' + item.cs)
      this.el.className = ['zft', 'grid', ...edges].join(' ')
    }
    setHideClass(noHide) {
      this.el.className = noHide ? 'zft' : ['zft', ...Object.keys(this.hideFace).map(item => item - -1)].join(' h')
    }
    hide() {
      this.upStyle('opacity', '0')
    }
    show() {
      this.upStyle('opacity', this.style.opacity || '0.8')
    }
  }

  class Block {
    constructor(cubes, parent, size, parentNode, documentFragment) {
      this.hub = {}
      this.cubes = cubes
      this.parent = parent
      this.offset = [0, 0, 0]
      this.size = size
      this.rotateAngle = [0, -1, 0] //x,y,z
      const part = document.createElement('div')
      part.className = 'part'
      this.scrollLayer = part
      const partView = document.createElement('div')
      partView.className = 'part-perspective'
      this.perspectiveLayer = partView
      this.containerLayer = parentNode
      partView.appendChild(parentNode)
      part.appendChild(partView)
      documentFragment.appendChild(part)
      // this.parentNode = partContainer
      /* numArr.map(item => nums2arrs(item)).forEach((a, ai) => {
        a.forEach((b, bi) => {
          b.forEach((c, ci) => {
            if (c) {
              const str = (ai + 1) * 1000 + [4, 2, 1][ci] * 10 ** (2 - bi)
              this.hub[str] = luban[2 - ai][bi][ci]
            }
          })
        })
      }) */
      //this.setHideFace(bgColor, noHide)
    }
    init(numArr, bgColor, noHide, offset) {
      if (offset !== undefined) {
        this.offset = offset || [0, 0, 0]
        this.containerLayer.style.cssText = `transform: translate3d(calc(-50% + ${this.offset[0] * this.size}px),calc(-50% + ${this.offset[1] * this.size}px),${((1 + this.offset[2]) * this.size)}px)`
      }
      this.setSite(numArr)
      this.setColor(bgColor)
      this.setHideFace(bgColor, noHide)
    }
    setSite(numArr) {
      numArr.numSort().forEach((item, index) => {
        const cube = this.cubes[index]
        this.hub[item] = cube
        cube.site = point2site(item)
      })
    }
    setColor(color) {
      this.bgColor = color
    }
    setHideFace(color, noHide) {
      for (let point in this.hub) {
        const one = this.hub[point]
        const cp = points[point]
        for (let c in cp) {
          const p = cp[c]
          if (c in this.hub) {
            this.hub[c].hideFace[5 - p.cs] = point
            one.hideFace[p.cs] = c
          }
        }
      }
      for (let k in this.hub) {
        this.hub[k].style.background = color
        this.hub[k].show()
        this.hub[k].setHideClass(noHide)
      }
    }
    setStyle(style) {
      for (let k in this.hub) {
        Object.assign(this.hub[k].style, style)
      }
    }
    hideSelf() {
      for (let k in this.hub) {
        this.hub[k].hide()
      }
    }
    showSelf() {
      for (let k in this.hub) {
        this.hub[k].show()
      }
    }
    hideSelf() {
      for (let k in this.hub) {
        this.hub[k].hide()
      }
    }
    hideOther() {
      this.parent.forEach(item => {
        if (item !== this) {
          item.hideSelf()
        } else {
          item.showSelf()
        }
      })
    }
  }

  class ACB { // assemble cube
    constructor(el, size) {// num = 27|4|3
      this.blocks = []
      const df = document.createDocumentFragment()
      for (let i = 0; i < 7; i++) {
        const block = []
        const partContainer = document.createElement('div')
        partContainer.className = 'part-container'
        for (let j = 0; j < (i === 0 ? 3 : 4); j++) {
          block.push(new SmallCube(partContainer, [0, 0, 0], size))
        }
        this.blocks.push(new Block(block, this.blocks, size, partContainer, df))
      }
      el.appendChild(df)
    }
    load(data, colors, noHide) {
      this.show()
      let p3
      const res = data.map(item => {
        // return { offset: bulks[item].offset, points: block2points(bulks[item].points) }
        return { offset: bulks[item].offset, points: bulks[item].points }
      }).filter(item => item.points.length === 3 ? (p3 = item, false) : true);
      ([p3, ...res]).forEach((item, index) => {
        this.blocks[index].init(item.points, (colors && colors[index]) || 'transparent', noHide, item.offset)
      })
    }
    getChildren() {
      return [...this.blocks]
    }
    show(indexs) {
      const isArr = Array.isArray(indexs)
      this.blocks.forEach((item, index) => {
        if ((isArr && indexs.includes(index)) || index === indexs) {
          item.showSelf()
        } else {
          item.hideSelf()
        }
      })
    }
    hide(indexs) {
      const isArr = Array.isArray(indexs)
      this.blocks.forEach((item, index) => {
        if ((isArr && indexs.includes(index)) || index === indexs) {
          item.hideSelf()
        } else {
          item.showSelf()
        }
      })
    }
  }

  // [<,-][田,T,刁,L,Z,厶,マ]
  const bulks = {
    '-2': {
      points: [1040, 1002, 1004],
      offset: [0.5, -0.5, -2.5]
    },
    '-1': {
      points: [1004, 2004, 3004],
      offset: [1, -1, -1.5]
    },
    0: {
      points: [1040, 1020, 1004, 1002],
      offset: [0.5, -0.5, -2.5]
    },
    1: {
      points: [1020, 1004, 1002, 1001],
      offset: [0, -0.5, -2.5]
    },
    2: {
      points: [1040, 1020, 1004, 2040],
      offset: [0.5, -0.5, -2]
    },
    3: {
      points: [1040, 1004, 1002, 1001],
      offset: [0, -0.5, -2.5]
    },
    4: {
      points: [1040, 1020, 1002, 1001],
      offset: [0, -0.5, -2.5]
    },
    5: {
      points: [1040, 1020, 1004, 2020],
      offset: [0.5, -0.5, -2]
    },
    6: {
      points: [1040, 1020, 1004, 2004],
      offset: [0.5, -0.5, -2]
    }
  }
  class Bulk {
    constructor(arr) {
      this.hub = arr
    }
    load(id) { // 

    }
  }

  function createBlocks(str) {//-1123456
    str += ''
    const arr = str.split('')
    const b3 = -arr[1]
    const b4s = str.slice
  }

  function ready(fn) {
    document.addEventListener('DOMContentLoaded', function readyFn() {
      document.removeEventListener('DOMContentLoaded', readyFn, false)
      fn()
    }, false)
  }

  class TouchEvent {
    static STATUS_DOWN = 0
    static STATUS_MOVE = 1
    static COMBO_DELAY = 500
    constructor($body) {
      this.hub = new WeakMap()
      this.touches = {}
      this.lock = false
      this.timer = null
      this.$body = $body
      $body.ontouchstart = this.startHandle.bind(this)
      $body.ontouchend = this.endHandle.bind(this)
      $body.ontouchmove = this.moveHandle.bind(this)
      $body.ontouchcancel = this.cancelHandle.bind(this)
    }
    register(payload) {
      const { el, ...events } = payload
      const oldObj = this.hub.get(el) || { combo: 0, lastDate: null }
      for (let eventName in events) {
        const value = events[eventName]
        if (eventName === 'click' || eventName === 'press') {
          oldObj[eventName] = oldObj[eventName] || {}
          oldObj[eventName][value[0]] = value.slice(1)
        } else {
          oldObj[eventName] = value
        }
      }
      this.hub.set(el, oldObj)
    }
    startHandle(event) {
      if (this.lock) {
        return
      }
      event.preventDefault()
      event.stopPropagation()
      const nowDate = new Date().getTime()
      Array.prototype.forEach.call(event.changedTouches, item => {
        const { pageX, pageY, identifier, target } = item
        if (!this.touches[identifier]) {
          let events
          let _target = target
          while (!0) {
            if (this.hub.has(_target)) {
              events = this.hub.get(_target)
              break
            } else if (_target === document.documentElement) {
              break
            } else {
              _target = _target.parentNode
            }
          }
          if (events) {
            const touch = { pageX: null, pageY: null, status: TouchEvent.STATUS_DOWN, events, startDate: new Date().getTime() }
            if (touch.events.lastDate && nowDate - touch.events.lastDate >= TouchEvent.COMBO_DELAY) {
              touch.events.combo = 0
            }
            touch.events.lastDate = nowDate
            this.touches[identifier] = touch
            if (events.start) {
              events.start.bind(touch)()
            }
            if (events.press) {
              const timeArr = Object.keys(events.press)
              const _this = this
              function timeFn() {
                if (timeArr.length) {
                  const time = timeArr.shift()
                  return setTimeout(() => {
                    const [fn, bubble] = events.press[time]
                    if (bubble) {
                      _this.timer = timeFn()
                    } else {
                      _this.timer = null
                    }
                    fn()
                  }, time)
                } else {
                  return null
                }
              }
              this.timer = timeFn()
            }
          }
        }
      })
    }
    moveHandle(event) {
      if (this.lock) {
        return
      }
      // event.preventDefault()
      event.stopPropagation()
      if (this.timer !== null) {
        clearTimeout(this.timer)
      }
      Array.prototype.forEach.call(event.changedTouches, item => {
        const { pageX, pageY, identifier } = item
        const touch = this.touches[identifier]
        if (!touch) {
          return
        }
        touch.status = TouchEvent.STATUS_MOVE
        if (touch.events.move && touch.pageX !== null) {
          touch.events.move.bind(touch)(pageX, pageY)
        }
        touch.pageX = pageX
        touch.pageY = pageY
      })
    }
    endHandle(event) {
      if (this.lock) {
        return
      }
      event.preventDefault()
      event.stopPropagation()
      if (this.timer !== null) {
        clearTimeout(this.timer)
      }
      const nowDate = new Date().getTime()
      Array.prototype.forEach.call(event.changedTouches, item => {
        const { pageX, pageY, identifier } = item
        const touch = this.touches[identifier]
        if (!touch) {
          return
        }
        const derDate = nowDate - touch.events.lastDate
        let execed = false
        if (touch.status === TouchEvent.STATUS_MOVE) {
          touch.events.combo = 0
        } else if (touch.status === TouchEvent.STATUS_DOWN) {
          if (touch.events.combo === 0) {
            if (derDate >= TouchEvent.COMBO_DELAY) {
              /* const pressKey = touch.events.press && Object.keys(touch.events.press).numSort()
              if (pressKey) {
                let tempDate = null
                for (let i = 0; i < pressKey.length; i++) {
                  if (pressKey[i] > derDate) {
                    break
                  } else {
                    tempDate = pressKey[i]
                  }
                }
                if (tempDate !== null) {
                  execed = true
                  touch.events.press[tempDate].bind(touch)()
                }
              } */
            } else {
              touch.events.combo += 1
            }
          } else {
            if (derDate >= TouchEvent.COMBO_DELAY) {
              touch.events.combo = 0
            } else {
              touch.events.combo += 1
            }
          }
          if (touch.events.combo > 0 && touch.events.click && touch.events.click[touch.events.combo] && touch.events.click[touch.events.combo][0]) {
            execed = true
            touch.events.click[touch.events.combo][0].bind(touch)()
          }
        }
        touch.events.lastDate = nowDate
        if (touch.events.end && !execed) {
          touch.events.end.bind(touch)(pageX, pageY)
        }
        delete this.touches[identifier]
      })
    }
    cancelHandle(event) {
      if (this.timer !== null) {
        clearTimeout(this.timer)
      }
      console.log('cancel:', event)
    }
  }
  function animation(len, fn, time, r = 0) {
    function dx(dt) {
      return (2 * v - dt * a) * dt / 2
    }
    function rafCallBack(timestamp) {
      !start && (start = timestamp)
      const dt = timestamp - start
      start = timestamp
      if (dt) {
        const dlen = dx(dt)
        fn(dlen)
        len -= dlen
        time -= dt
        v -= dt * a
      }
      if (time > dt) {
        window.requestAnimationFrame(rafCallBack)
      } else {
        fn(len, true)
        resolve()
      }
    }
    /* const maxA = 2 * len / time ** 2
    a = Math.min(maxA, a)
    let v = time * a / 2 + len / time */
    const maxV = len / time
    // v0 = Math.min(maxV, v0)
    const v0 = (r > 1 ? 1 : r) * maxV
    a = 2 * (maxV - v0) / time
    let v = time * a / 2 + len / time
    let start = null
    let resolve
    return new Promise(r => {
      resolve = r
      window.requestAnimationFrame(rafCallBack)
    })
  }
  ready(function () {
    ReactData.$body = document.body
    ReactData.$main = document.querySelector('.main')
    ReactData.$mainTouch = document.querySelector('.main-touch')
    ReactData.$byTouch = document.querySelector('.deputy-touch')
    ReactData.$pb = document.querySelector('.perspective')
    ReactData.$ct = document.querySelector('.container')
    ReactData.$varStyle = document.querySelector('#var-style')
    ReactData.$fixed = document.querySelector('.fixed')
    const fullscreenEnabled = document.fullscreenEnabled || document.mozFullScreenEnabled
    let isFullscreen = false
    document.body.onfullscreenchange = function (event) {
      let elem = event.target
      isFullscreen = document.fullscreenElement === elem

    }
    document.oncontextmenu = function (event) {
      event.preventDefault()
    }
    const { $body, $main, $pb, $ct, $fixed, $mainTouch, $byTouch } = ReactData
    let r = 1
    let startPos = null
    let posRotate = [75, -20]

    if ($pb) {
      const touch = new TouchEvent($body)
      touch.register({
        el: $mainTouch,
        click: [3, async function () {
          if (this.events.combo === 3) {
            if (fullscreenEnabled) {
              if (!isFullscreen) {
                await document.body.requestFullscreen()
              } else {
                await document.exitFullscreen()
              }
            }
          }
        }],
        move(pageX, pageY) {
          posRotate[1] -= ((pageX - this.pageX) * r).toFixed(2)
          posRotate[0] -= ((pageY - this.pageY) * r).toFixed(2)
          $pb.style.transform = `rotateX(${posRotate[0]}deg) rotateZ(${posRotate[1]}deg)`
        }
      })


      const swipers = document.querySelectorAll('.swiper')
      const screen = window.screen
      const $height = screen.availHeight
      const $width = screen.availWidth
      const fixWidth = $width * 0.3 //a
      const baseHeight = ($height - fixWidth) / 2
      const baseWidth = (baseHeight < fixWidth ? baseHeight : fixWidth * 0.6).toFixed(5) - 0 //b
      let distance = 0

      const exhibit = new ACB($fixed.children[0], fixWidth / 5 | 0)

      if (swipers) {
        Array.prototype.forEach.call(swipers, $swiper => {
          function setTranslate(border = false) {
            if (border) {
              distance = distance.toFixed(5) - 0
            }
            const isDown = distance > 0
            const len = byChildren.length
            const baseIndex = len / 2 | 0
            const indexDelta = distance / baseWidth | 0
            const offset = distance % baseWidth //c
            const offsetBase = (fixWidth - baseWidth) / 2
            const rate = fixWidth * offset / baseWidth
            distance = offset
            if (indexDelta) {
              if (indexDelta > 0) {
                byChildren.splice(0, 0, ...byChildren.splice(len - indexDelta, indexDelta))
              } else {
                byChildren.splice(len, 0, ...byChildren.splice(0, -indexDelta))
              }
            }
            byChildren.forEach((item, index) => {
              const scrollLayer = item.scrollLayer
              const baseTop = (index - baseIndex) * baseWidth + (index < baseIndex ? -offsetBase : offsetBase)
              if (isDown) {
                if (index === baseIndex - 1) {
                  const $scale = (baseWidth - offset + rate) / fixWidth
                  scrollLayer.style.cssText = `transform:translateY(${baseTop + (offset + rate) / 2}px) scale(${$scale},${$scale}) rotateX(90deg);`
                } else if (index === baseIndex) {
                  const $scale = (fixWidth + offset - rate) / fixWidth
                  scrollLayer.style.cssText = `transform:translateY(${(offset + rate) / 2}px) scale(${$scale},${$scale}) rotateX(90deg);`
                } else {
                  const $scale = baseWidth / fixWidth
                  scrollLayer.style.cssText = `transform:translateY(${baseTop + offset}px) scale(${$scale},${$scale}) rotateX(90deg);`
                }
              } else {
                if (index === baseIndex + 1) {
                  const $scale = (baseWidth + offset - rate) / fixWidth
                  scrollLayer.style.cssText = `transform:translateY(${baseTop + (rate + offset) / 2}px) scale(${$scale},${$scale}) rotateX(90deg);`
                } else if (index === baseIndex) {
                  const $scale = (fixWidth - offset + rate) / fixWidth
                  scrollLayer.style.cssText = `transform:translateY(${(rate + offset) / 2}px) scale(${$scale},${$scale}) rotateX(90deg);`
                } else {
                  const $scale = baseWidth / fixWidth
                  scrollLayer.style.cssText = `transform:translateY(${baseTop + offset}px) scale(${$scale},${$scale}) rotateX(90deg);`
                }
              }
            })
            if (border) {
              center.scrollLayer.classList.remove('center')
              center = byChildren[baseIndex]
              center.scrollLayer.classList.add('center')
            }
          }

          // const children = Array.from($swiper.children)
          const byChildren = exhibit.getChildren()
          let mode = 0 //0:scroll; 1:rotate; 2:move;
          let center = byChildren[byChildren.length / 2 | 0]
          setTranslate()
          touch.register({
            el: $byTouch,
            move(pageX, pageY) {
              if (mode === 0) {
                distance += (pageY - this.pageY) * baseWidth * 2 / $height
                setTranslate()
              } else if (mode === 1) {
                const dx = pageX - this.pageX
                const dy = pageY - this.pageY
                center.rotateAngle = rotVector(center.rotateAngle, getK(dx, dy, 10))
                const rotK = rotate3d([0, -1, 0], center.rotateAngle)
                center.perspectiveLayer.style.transform = `rotate3d(${rotK.join(',')}rad)`
              }

            },
            async end() {
              this.lock = true
              if (mode === 0) {
                if (distance > 0) {
                  if (distance > baseWidth / 2) {
                    await animation(baseWidth - distance, (dy, done) => {
                      distance += dy
                      setTranslate(done)
                    }, 300, 0.5)
                  } else {
                    await animation(distance, (dy, done) => {
                      distance -= dy
                      setTranslate(done)
                    }, 300, 0.5)
                  }
                } else if (distance < 0) {
                  if (-distance > baseWidth / 2) {
                    await animation(baseWidth + distance, (dy, done) => {
                      distance -= dy
                      setTranslate(done)
                    }, 300, 0.5)
                  } else {
                    await animation(-distance, (dy, done) => {
                      distance += dy
                      setTranslate(done)
                    }, 300, 0.5)
                  }
                }
              }
              this.lock = false
            },
            click: [2, function () {
              mode = mode === 1 ? 0 : 1
              if (mode === 1) {
                center.scrollLayer.classList.remove('center')
                center = byChildren[byChildren.length / 2 | 0]
                center.scrollLayer.classList.add('center')
              } else {
                center.scrollLayer.classList.remove('center')
              }
            }],
            press: [1000, function () {
              mode = mode === 2 ? 0 : 2
            }]
          })
        })
      }

      const shadow = {
        hub: {},
        assembled: [],
        actived: [],
        rested: [],
        init() {
          this.rested.length = 0
          this.actived.length = 0
          this.assembled.length = 0
          for (k in this.hub) {
            this.rested.push(k)
            // this.hub[k].style.background = '#4cbbf380'
            // this.hub[k].style.background = 'transparent'
          }
        },
        render() {
          this.rested.forEach(item => this.hub[item].setGrid(this.rested))
        }
      }
      const df = document.createDocumentFragment()
      for (let f = 2; f >= 0; f--) {
        for (let r = 0; r < 3; r++) {
          for (let c = 0; c < 3; c++) {
            str = (3 - f) * 1000 + [4, 2, 1][c] * 10 ** (2 - r)
            shadow.hub[str] = new SmallCube(df, [f, r, c])
          }
        }
      }
      // shadow.hub['3001'] = new SmallCube(df, [0, 2, 2])
      $ct.children[1].appendChild(df)
      shadow.init()
      shadow.render()
      exhibit.load([-1, 3, 6, 2, 5, 4, 1
        /* [1000, 2000, 3170],
        [1000, 2011, 3003],
        [1000, 2320, 3200],
        [1004, 2004, 3004],
        [1013, 2002, 3000],
        [1040, 2440, 3400],
        [1720, 2000, 3000] */
      ], ['red', 'orange', 'yellow', 'green', 'cyan', 'blue', 'purple'])
      window.$ehb = exhibit



      // 创建操作区
      /* function createOperationBlocks(num, blocks) {
        const ob = document.createElement('div')
        ob.className = 'operation-blocks'
        for (let i = 0; i < num; i++) {
          blocks[i] = new SmallCube(ob)
        }
        return ob
      }
      const odf = document.createDocumentFragment()
      const operationBlocks = [[]]
      odf.appendChild(createOperationBlocks(3, operationBlocks[0]))
      for (let i = 1; i < 7; i++) {
        operationBlocks[i] = []
        odf.appendChild(createOperationBlocks(4, operationBlocks[i]))
      }

      $fixed.appendChild(odf) */

      /* ReactData.collection = {
        arr: [],
        load(data, colors, noHide) {
          this.show()
          this.arr.length = 0
          data.forEach((a, i) => this.arr.push(new Block(a, luban, (colors && colors[i]) || 'white', this.arr, noHide)))
        },
        show(indexs) {
          const isArr = Array.isArray(indexs)
          this.arr.forEach((item, index) => {
            if ((isArr && indexs.includes(index)) || index === indexs) {
              item.showSelf()
            } else {
              item.hideSelf()
            }
          })
        },
        hide(indexs) {
          const isArr = Array.isArray(indexs)
          this.arr.forEach((item, index) => {
            if ((isArr && indexs.includes(index)) || index === indexs) {
              item.hideSelf()
            } else {
              item.showSelf()
            }
          })
        },
      } */
    }
  })
</script>
</html>